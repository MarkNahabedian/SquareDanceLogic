// Definitions and rules about all two dancer square dance formations.
package reasoning

import "squaredance/dancer"
import "squaredance/geometry"


// Pair represents two distinct Dancers.
// Note that rule_PairOfDancers does not filter by Dancer canonical ordering
// and the rete node that Joins one Dancer with another considers the those
// Dancers in both possible orderings, so for every two Dancers, two Pairs
// are made, one with one dancer as Dancer1, and the other with the other
// Danceer as Dancer1.  This should simplify a number of the other two Dancer
// rules, which dont need to consider which Dancer is which in a given Pair
// because there will be another Pair with its Dancers in the other ordering.
type Pair interface {
	// Should Pair be a Formation?
	Pair()
	Dancer1() dancer.Dancer
	Dancer2() dancer.Dancer
}

func MakePair(dancer1, dancer2 dancer.Dancer) Pair {
	return Pair(&pair{ dancer1: dancer1, dancer2: dancer2 })
}

type pair struct {
	dancer1 dancer.Dancer
	dancer2 dancer.Dancer
}

func (p *pair) Pair() {}

// Dancer1 returns one dancer of a Pair.
func (p *pair) Dancer1() dancer.Dancer {
	return p.dancer1
}

// Dancer2 returns the Dancer of the Pair that is not returned by Dancer1.
func (p *pair) Dancer2() dancer.Dancer {
	return p.dancer2
}

// rule_PairOfDancers groups each two Dancers pairwise.
func rule_PairOfDancers(dancer1, dancer2 dancer.Dancer) {
	// Note that for each pair of dancers we will create two Pair
	// objects: one each for the two possible orders of the dancers.
	if dancer1 != dancer2 {
		__node.Emit(Pair(&pair{dancer1: dancer1, dancer2: dancer2}))
	}
}


// TODO: Need to test for nearness or adjacency.


// A Couple consists of two Dancers that are side by side and facing the
// same direction.  Since one Dancer is to the right of the other Dancer
// the same two Dancers can only be in a Couple one way.
type Couple interface {
	Formation
	Couple()
	Beau() dancer.Dancer
	Belle() dancer.Dancer
	// Roles:
	Beaus() []dancer.Dancer    // no-slot
	Belles() []dancer.Dancer   // no-slot
}

func (f *implCouple) Beaus() []dancer.Dancer { return []dancer.Dancer{ f.Beau() } }
func (f *implCouple) Belles() []dancer.Dancer { return []dancer.Dancer{ f.Belle() } }

func rule_GeneralizedCouple(p Pair) {
	d1 := p.Dancer1()
	d2 := p.Dancer2()
	if RightOf(d1, d2) && LeftOf(d2, d1) {
		__node.Emit(Couple(&implCouple{beau: d1, belle: d2}))
	}
}


// A MiniWave consists of two Dancers facing in opposite directions.
// There isn't anything inate to a MiniWave that would restrict which
// of the same two Dancers is Dancer1 versus which is Dancer2 unless
// we resort to Dancer.Ordinal.
type MiniWave interface{
	Formation
	MiniWave()
	Dancer1() dancer.Dancer
	Dancer2() dancer.Dancer
    // Handedness
	Handedness() Handedness   // no-slot
	// Roles
	Beaus() []dancer.Dancer   // no-slot
	Belles() []dancer.Dancer  // no-slot
}

func (mw *implMiniWave) Handedness() Handedness {
	if RightOf(mw.Dancer1(), mw.Dancer2()) {
		return RightHanded
	}
	return LeftHanded
}

func (mw *implMiniWave) Beaus() []dancer.Dancer {
	switch mw.Handedness() {
		case RightHanded:
			return []dancer.Dancer{
				mw.Dancer1(), 
				mw.Dancer2(), 
			}
		case LeftHanded:
			return []dancer.Dancer{}
		default:
			panic("MiniWave is neither right nor left handed.")
	}
}

func (mw *implMiniWave) Belles() []dancer.Dancer {
	switch mw.Handedness() {
		case RightHanded:
			return []dancer.Dancer{}
		case LeftHanded:
			return []dancer.Dancer{
				mw.Dancer1(), 
				mw.Dancer2(), 
			}
		default:
			panic("MiniWave is neither right nor left handed.")
	}
}

func rule_MiniWave(p Pair) {
	d1 := p.Dancer1()
	d2 := p.Dancer2()
	if d1.Ordinal() >= d2.Ordinal() {
		return
	}
	if RightOf(d1, d2) && RightOf(d2, d1) {
		__node.Emit(MiniWave(&implMiniWave{dancer1: d1, dancer2: d2}))
		return
	}
	if LeftOf(d1, d2) && LeftOf(d2, d1) {
		__node.Emit(MiniWave(&implMiniWave{dancer1: d1, dancer2: d2}))
	}
}


// FaceToFace represents two dancewrs that are facing each other.
type FaceToFace interface {
	Formation
	FaceToFace()
	Dancer1() dancer.Dancer
	Dancer2() dancer.Dancer
	// Roles
	Leaders() []dancer.Dancer    // no-slot
	Trailers() []dancer.Dancer   // no-slot
}

func (f *implFaceToFace) Leaders() []dancer.Dancer {
	return []dancer.Dancer {}
}

func (f *implFaceToFace) Trailers() []dancer.Dancer {
	return []dancer.Dancer {
		f.Dancer1(),
		f.Dancer2(),
	}
}

func rule_FaceToFace(p Pair) {
	d1 := p.Dancer1()
	d2 := p.Dancer2()
	if d1.Ordinal() >= d2.Ordinal() {
		return
	}
	if InFrontOf(d1, d2) && InFrontOf(d2, d1) {
		__node.Emit(FaceToFace(&implFaceToFace{dancer1: d1, dancer2: d2}))
	}
}


// BackToBack represents two dancers with their backs to each other.
type BackToBack interface {
	Formation
	BackToBack()
	Dancer1() dancer.Dancer
	Dancer2() dancer.Dancer
	// Roles:
	Leaders() []dancer.Dancer   // no-slot
}

func (f *implBackToBack) Leaders() []dancer.Dancer {
	return []dancer.Dancer {
		f.Dancer1(),
		f.Dancer2(),
	}
}

func rule_BackToBack(p Pair) {
	d1 := p.Dancer1()
	d2 := p.Dancer2()
	if d1.Ordinal() >= d2.Ordinal() {
		return
	}
	if Behind(d1, d2) && Behind(d2, d1) {
		__node.Emit(BackToBack(&implBackToBack{dancer1: d1, dancer2: d2}))
	}
}


// Tandem represents two dancers facing the same direction with the Leader
// in front of the Trailer.
type Tandem interface {
	Formation
	Tandem()
	Leader() dancer.Dancer
	Trailer() dancer.Dancer
	Direction() geometry.Direction  // no-slot
	// Roles:
	Leaders() []dancer.Dancer   // no-slot
	Trailers() []dancer.Dancer   // no-slot
}

func (f *implTandem) Leaders() []dancer.Dancer {
	return []dancer.Dancer{ f.Leader() }
}

func (f *implTandem) Trailers() []dancer.Dancer {
	return []dancer.Dancer{ f.Trailer() }
}

func rule_Tandem(p Pair) {
	d1 := p.Dancer1()
	d2 := p.Dancer2()
	if !d1.Direction().Equal(d2.Direction()) {
		return
	}
	if Behind(d1, d2) && InFrontOf(d2, d1) {
		__node.Emit(Tandem(&implTandem{leader: d1, trailer: d2}))
	}
}

