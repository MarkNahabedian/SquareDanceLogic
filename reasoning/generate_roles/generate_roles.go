package main

import "fmt"
import "os"
import "text/template"


// Format string has a single multiply occuring parameter: the role name.
var roles_template *template.Template = template.Must(template.New("generated_roles").Parse(`

type {{.InterfaceName}} interface {
	{{.FormationMethodName}}() []dancer.Dancer
}

type {{.ImplementationTypeName}} struct {}

func (r *{{.ImplementationTypeName}}) Name() string {return "{{.Name}}" }

func (r *{{.ImplementationTypeName}}) MeaningfulTo(f Formation) bool {
	_, ok := f.({{.InterfaceName}})
	return ok
}

func (r *{{.ImplementationTypeName}}) Dancers(f Formation) []dancer.Dancer {
	if f,  ok := f.({{.InterfaceName}}); ok {
		return f.{{.FormationMethodName}}()
	}
	return []dancer.Dancer{}
}

func init() {
	Roles = append(Roles, &{{.ImplementationTypeName}}{})
}


`)) // End of code template

type protoRole struct {
	name string
}

func (pr *protoRole) Name() string { return pr.name }
func (pr *protoRole) FormationMethodName() string { return pr.Name() }
func (pr *protoRole) InterfaceName() string { return "Has" + pr.Name() }
func (pr *protoRole) ImplementationTypeName() string { return pr.Name() }

var roles []*protoRole = [] *protoRole {
	&protoRole{name: "Beau"},
	&protoRole{name: "Belle"},
	&protoRole{name: "Center"},
	&protoRole{name: "End"},
	&protoRole{name: "Point"},
	&protoRole{name: "Leader"},
	&protoRole{name: "Trailer"},
	&protoRole{name: "VeryCenter"},
	&protoRole{name: "Outside"},
}

const output_file string = "generated_roles.go"

func main() {
	f, err := os.Create(output_file)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Can't create %s: %s", output_file, err)
		return
	}
	defer f.Close()
	fmt.Fprintf(f, "// THIS FILE WAS AUTOMATICALLY GENERATED BY generate_rules.\n\n")
	fmt.Fprintf(f, "package reasoning\n")
	fmt.Fprintf(f, "import \"squaredance/dancer\"\n\n")
	for _, role := range roles {
		roles_template.Execute(f, role)
	}
}
