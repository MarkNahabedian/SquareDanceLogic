/*
formation_expander looks for Formation interface definitions in a
go source file and writes a new source file with additional
definitions that implement Formation methods.

formation_expander should be used in conjunction with defimpl.

For example, we start with the definition

type TwoFacedLine interface {
	Formation
	TwoFacedLine()
	Couple1() Couple      // defimpl:"read couple1" fe:"dancers"
	Couple2() Couple      // defimpl:"read couple2" fe:"dancers"
	MiniWave() MiniWave
	Handedness()
}

From the above, defimpl would generate the definition of the
implementing struct

type TwoFacedLineImpl struct {
	couple1 Couple
	couple2 Couple
}

and the field accessor methods

func (f *TwoFacedLineImpl) Couple1() Couple { return f.couple1 }
func (f *TwoFacedLineImpl) Couple2() Couple { return f.couple2 }
func (f *TwoFacedLineImpl) MiniWave() Couple { return f.miniwave }

formation_expander will define the methods of the Formation interface
itself:

func (f *TwoFacedLineImpl) NumberOfDancers() int { ... }
func (f *TwoFacedLineImpl) Dancers() dancer.Dancers { ... }
func (f *TwoFacedLineImpl) HasDancer(d dancer.Dancer) bool { ... }

func init() {
	foo := func(f TwoFacedLine) {}
	t := reflect.TypeOf(foo).In(0)
	AllFormationTypes[t.Name()] = t
}

*/

package main

import "bytes"
import "flag"
import "fmt"
import "os"
import "path"
import "reflect"
import "strings"
import "text/template"
import "defimpl/util"
import "go/ast"
import "go/parser"
import "go/token"
import "go/format"


// Any method of a Formation interface definition that has a comment
// containing this keyword is used to help compute the Dancers of the
// formation.
const DancersTag = "dancers"


var Usage = func() {
	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "%s formation_defining_go_source_file...\n", os.Args[0])
	fmt.Fprintf(os.Stderr, "For each interface definition that defines a Formation type, generates the implementation of that formation.\n")
	flag.PrintDefaults()
}


func main() {
	flag.Parse()
	input_fileset := token.NewFileSet()
	for _, f := range flag.Args() {
		processFile(input_fileset, f)
	}
}


func output_path(input_path string) string {
	cleaned := path.Clean(input_path)
	return path.Join(path.Dir(cleaned), "feout_" + path.Base(cleaned))
}


const output_file_template string = `
// This file was automatically generated by %s from %s.
package foo
import "reflect"
import "squaredance/dancer"
` // end


func processFile(input_fileset *token.FileSet, filepath string) {
	fmt.Printf("formation_expander processing file %s\n", filepath)
	astFile, err := parser.ParseFile(input_fileset, filepath, nil, parser.ParseComments)
	if err != nil {
		fmt.Fprintf(os.Stderr, "%s\n", err)
		return
	}
	any := false
	package_name := astFile.Name.Name
	output_fileset := token.NewFileSet()
	newAstFile, err := parser.ParseFile(output_fileset, "",
		fmt.Sprintf(output_file_template,
			os.Args[0], filepath),
		parser.ParseComments)
	newAstFile.Name = ast.NewIdent(package_name)    // package name
	for _, decl := range astFile.Decls {
		ok, fdef := IsFormationDefinition(input_fileset, decl)
		if !ok {
			continue
		}
		any = true
		newAstFile.Decls = append(newAstFile.Decls,
			fdef.generate(output_fileset)...)
	}
	if !any {
		fmt.Fprintf(os.Stderr, "  No new definitions.\n")
		return
	}
	output_file := output_path(filepath)
	out, err := os.Create(output_file)
	if err != nil {
		fmt.Fprintf(os.Stderr, "  Can't create %s: %s", output_file, err)
		return
	}
	format.Node(out, output_fileset, newAstFile)
	out.Close()
	fmt.Printf("  Wrote %s\n", output_file)
}


// Our internal represerntation of a parsed formation definition -- something
// we can hang convenience methods off of.
type formationDef struct {
	fset *token.FileSet
	ts *ast.TypeSpec
	fields []*ast.Field
}


var formation_methods_template = template.Must(template.New("formation_methods_template").Parse(`
package foo

func (f *{{.STRUCT_TYPE}}) NumberOfDancers() int {
	count := 0
{{range .READERMETHODS}}
	count += f.{{.}}().NumberOfDancers()
{{end}}
	return count
}

func (f *{{.STRUCT_TYPE}}) Dancers() dancer.Dancers {
	dancers := dancer.Dancers {}
{{range .READERMETHODS}}
	dancers = append(dancers, f.{{.}}().Dancers()...)
{{end}}
	return dancers
}

func (f *{{.STRUCT_TYPE}}) HasDancer(d dancer.Dancer) bool {
{{range .READERMETHODS}}
	if f.{{.}}().HasDancer(d) {
		return true
	}
{{end}}
	return false
}

func init() {
	foo := func(f {{.FORMATION_NAME}}) {}
	t := reflect.TypeOf(foo).In(0)
	AllFormationTypes[t.Name()] = t
}

`)) // end


func (fdef *formationDef) generate(output_fileset *token.FileSet) (decls []ast.Decl) {
	implName := util.ImplName("", fdef.ts.Name.Name)   // WHERE DO WE GET PACKAGE FROM?
	// field reader methods for unique dancers
	unique_dancers := []string{}
	for _, field := range fdef.fields {
		for _, name := range field.Names {
			if commentHasKeyword(field.Comment, DancersTag) {
				unique_dancers = append(unique_dancers, name.Name)
			}
		}
	}
	// Formation methods
	b :=bytes.NewBufferString("")
	err := formation_methods_template.Execute(b,
		struct {
			STRUCT_TYPE string
			FORMATION_NAME string
			READERMETHODS []string
		} {
			STRUCT_TYPE: implName,
			FORMATION_NAME: fdef.ts.Name.Name,
			READERMETHODS: unique_dancers,
		})
	if err != nil {
		panic(err)
	}
	code := parseDefinition(b.String())
	return code.Decls
}


func commentHasKeyword(cmt ast.Node, keyword string) bool {
	tag_test := func(comment string) bool {
		val, ok := reflect.StructTag(comment[2:]).Lookup("fe")
		return ok && strings.Contains(val, keyword)
	}
	switch c := cmt.(type) {
	case *ast.Comment:
		if cmt == nil {
			return false
		}
		return tag_test(c.Text)
	case *ast.CommentGroup:
		if c == nil {
			return false
		}
		for _, c1 := range c.List {
			if tag_test(c1.Text) {
				return true
			}
		}
	}
	return false
}

func IsFormationDefinition(fset *token.FileSet, decl ast.Decl) (bool, *formationDef) {
	gd, ok := decl.(*ast.GenDecl)
	if !ok {
		return false, nil
	}
	spec, ok := gd.Specs[0].(*ast.TypeSpec)
	if !ok {
		return false, nil
	}
	it, ok := spec.Type.(*ast.InterfaceType)
	if !ok {
		return false, nil
	}
	if len(gd.Specs) > 1 {
		fmt.Fprintf(os.Stderr, "  Type definition of an interface type has more than one Spec: %s\n",
			fset.Position(gd.TokPos).String())
	}
	foundFormation := false
	fd := &formationDef {
		fset: fset,
		ts: spec,
	}
	fieldIsFormation := func(field *ast.Field) bool {
		return NodeString(field.Type) == "Formation"
	}
	for _, field := range it.Methods.List {
		if fieldIsFormation(field) {
			foundFormation = true
			continue
		}
		// Collect the fields that aren't the Formation interface.
		fd.fields = append(fd.fields, field)
	} 
	if !foundFormation {
		return false, nil
	}
	return true, fd
}


func parseExpression(exp string) ast.Expr {
	e, err := parser.ParseExpr(exp)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Offending code:\n%s\n", exp)
		panic(err)
	}
	return e
}

func parseDefinition(def string) *ast.File {
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "", def, parser.ParseComments)
	if err != nil {
		panic(fmt.Sprintf("Errors:\n%s", err))
	}
	return astFile
}

func NodeString(n ast.Node) string {
	w := bytes.NewBufferString("")
	format.Node(w, token.NewFileSet(), n)
	return w.String()
}

